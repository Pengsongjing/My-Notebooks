```
1. let和const命令
2. 变量的解构赋值
3. 字符串的扩展
4. 字符串新增的方法
```

#### let 和 const 命令

###### let 命令

```
let 所声明的变量，只在 let 命令所在的代码块内有效
	—— var 命令会发生变量提升，即变量可以在声明前使用，值为undefined
	—— let 命令所声明的变量一定要在声明后使用，否则报错
暂时性死区：
	只要块级作用域内存在let，它所声明的变量就“绑定”这个区域，不再受外部的影响
	var t = 123;
	if(true){
	  t = 'abc'; // ReferenceError
	  let t;
	}
```

###### const 命令

```
const 声明一个只读的常量，一旦声明，常量的值就不能改变
	—— const一旦声明变量，就必须立即初始化，不能留到以后赋值
	—— 只在声明所在的块级作用域内有效
	—— 同样存在暂时性死区，且只能在声明的位置后面使用
本质：
	const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动
```

###### 顶层对象的属性

```react
顶层对象，在浏览器环境指的是window对象，在Node指的是global对象
—— var和function声明的全局变量，依然是顶层对象的属性
—— let、const和class声明的全局变量。不属于顶层对象的属性
	var a = 1
	window.a // 1
	let b = 1
	window.b // undefined
```

#### 变量的解构赋值

###### 数组的解构赋值

```
ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构
—— 如果解构不成功，变量的值就等于 undefined

默认值：
	解构赋值允许指定默认值
	let [foo = true] = []
	
	—— ES6内部使用严格相等运算符（===）判断一个位置是否有值，只有当一个数组成员严格等于undefined，默认值就会生效
	—— 如果默认值是一个表达式，那么这个表达式是惰性求值，只有在用的时候才会求值
```

###### 对象的解构赋值

```react
对象的解构与数组有一个重要的不同
	—— 数组是按照次序排序的，变量的取值由它的位置决定
    —— 对象的属性没有次序，变量必须与属性同名，才能取到正确的值
    —— 变量名没有对应的属性名，取不到值，最后等于undefined
    
对象的解构赋值是下面形式的简写
let {foo: foo, bar: bar} = {foo: 'aaa', bar: 'bbb'}
	也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋值给对应的变量，真正被赋值的是后者，而不是前者
	let {foo: baz} = {foo:'aaa', bar:'bbb'}
	baz // 'aaa'
	foo // error: foo is not defined
```

###### 字符串的解构赋值

```
字符串被转换成一个类似数组的对象，所以可以解构赋值
	—— 类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值
```

###### 数值和布尔值的解构赋值

```react
解构赋值时，如果等号右边是数值和布尔值，则会先转为对象
let { toString: s } = 123;
s === Number.prototype.toString // true
```

###### 用途

```
1.交换变量的值
	let x = 1
	let y = 2
	[x,y] = [y,x]
2.从函数返回多个值
	函数只能返回一个值，如果要返回多个值，可以将他们放在数组或对象里，使用解构赋值取出值
```

#### 字符串扩展

###### 字符发Unicode表示法

```
ES6加强了对Unicode的支持，允许采用 \uxxxx 形式表示一个字符，其中 xxxx 表示字符的Unicode码点
```

###### 字符串的遍历器接口

```
ES6为字符串添加了遍历器接口，使得字符串可以被 for...of 循环遍历
```

#### 字符串新增方法

###### String.fromCodePoint()

```react
用于从Unicode码点返回对应字符，但是这个方法不能识别大于0xFFFF的字符
String.fromCharCode(0x20BB7)
// "ஷ"
```

###### String.raw()

```react
ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。
String.raw`Hi\n${2+3}!`
// 实际返回 "Hi\\n5!"，显示的是转义后的结果 "Hi\n5!"
```

##### 实例方法

###### codePointAt()

```
对于4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。
ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。
```

###### normalize()

```
ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。
```

###### includes()、startsWith()、endsWith()

```react
传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法
	—— includes()：返回布尔值，表示是否找到了参数字符串
	—— startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部
	—— endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部
    
let s = 'Hello world!';
s.startsWith('Hello') // true
s.endsWith('!') // true
s.includes('o') // true

这三个方法都支持第二个参数，表示开始搜索的位置，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束
```

###### repeat()

```
repeat方法返回一个新字符串，表示将原字符串重复n次
```

###### padStart()、padEnd()

```
如果某个字符串不够指定长度，会在头部或尾部补全
padStart()和padEnd()一共接受两个参数
	—— 第一个参数是字符串补全生效的最大长度
	—— 第二个参数是用来补全的字符串
	—— 如果省略第二个参数，默认使用空格补全长度
```

###### trimStart()、trimEnd()

```
ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法
	—— 它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格
	—— 它们返回的都是新字符串，不会修改原始字符串
```

